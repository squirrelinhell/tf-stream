#!/usr/bin/python3

import sys

if len(sys.argv) < 2:
    sys.stderr.write("\nUsage:\n\n");
    sys.stderr.write("\ttrain_mnist_conv <output.model>\n\n")
    sys.exit(1)

import os
import loadsave
import numpy as np
import tensorflow as tf
import tensorflow.examples.tutorials.mnist as tf_mnist

from utils import *

def dense(x, out_dim):
    in_dim = np.prod([1 if v is None else v for v in x.shape.as_list()])
    x = tf.reshape(x, [-1, in_dim])
    b = tf.Variable(tf.constant(0.1, shape = [out_dim]))
    w = tf.Variable(tf.truncated_normal(
        [in_dim, out_dim],
        stddev = 0.1
    ))
    return tf.matmul(x, w) + b

def conv(x, ksize, filters):
    in_channels = x.shape[-1].value
    b = tf.Variable(tf.constant(0.1, shape = [filters]))
    w = tf.Variable(tf.truncated_normal(
        [ksize, ksize, in_channels, filters],
        stddev = 0.1
    ))
    return tf.nn.conv2d(
        x, w,
        strides = [1, 1, 1, 1],
        padding = 'SAME'
    ) + b

def maxpool(x, size):
    return tf.nn.max_pool(
        x,
        ksize = [1, size, size, 1],
        strides = [1, size, size, 1],
        padding = 'SAME'
    )

def create_model():
    x = tf.placeholder(tf.float32, [None, 28, 28], name = "x")
    t = tf.placeholder(tf.float32, [None, 10], name = "t")
    dropout = tf.placeholder_with_default(0.0, [], name = "dropout")

    y = tf.reshape(x, [-1, 28, 28, 1])

    y = conv(y, 5, 32)
    y = tf.nn.relu(y)
    y = maxpool(y, 2)

    y = conv(y, 5, 64)
    y = tf.nn.relu(y)
    y = maxpool(y, 2)

    y = dense(y, 1024)
    y = tf.nn.relu(y)

    y = tf.nn.dropout(y, 1.0 - dropout)

    y = dense(y, 10)

    correct = tf.equal(tf.argmax(y, 1), tf.argmax(t, 1))
    correct = tf.cast(correct, tf.float32)

    tf.cast(tf.reduce_sum(1.0 - correct), tf.int64, name = "mistakes")
    tf.reduce_mean(correct, name = "accuracy")

    tf.nn.softmax(y, 1, name = "y")

    loss = tf.reduce_mean(
        tf.nn.softmax_cross_entropy_with_logits(labels=t, logits=y),
        name = "loss"
    )

    global_step = tf.contrib.framework.get_or_create_global_step()

    tf.train.AdamOptimizer(0.0001).minimize(
        loss,
        global_step = global_step,
        name = "train"
    )

def compute_stats(s, batch):
    x_v, t_v = batch
    x_v = np.reshape(x_v, [-1, 28, 28])
    num_samples = len(x_v)
    if num_samples <= 1024:
        v = s.run(
            [s.accuracy, s.loss, s.mistakes],
            feed_dict = {s.x: x_v, s.t: t_v}
        )
        return {
            "accuracy": v[0],
            "loss": v[1],
            "mistakes": v[2],
            "samples": num_samples
        }

    # Split computation into batches of 1024
    ret = {}
    while len(x_v) > 0:
        part = x_v[0:1024], t_v[0:1024]
        x_v, t_v = x_v[1024:], t_v[1024:]
        part_stat = compute_stats(s, part)
        part_stat["accuracy"] *= len(part[0])
        part_stat["loss"] *= len(part[0])
        ret = dict_sum(ret, part_stat)
    ret["accuracy"] /= num_samples
    ret["loss"] /= num_samples
    return ret

def format_stats(v):
    return "%6.2f%% (%d/%d), loss=%f" % (
        v["accuracy"] * 100.0,
        v["samples"] - v["mistakes"],
        v["samples"],
        v["loss"]
    )

def print_stats(s, mnist):
    sys.stderr.write("%10d: " % s.global_step.eval())
    sys.stderr.flush()
    v = compute_stats(s, (mnist.train.images, mnist.train.labels))
    sys.stderr.write(" [train] %s " % format_stats(v))
    sys.stderr.flush()
    v = compute_stats(s, (mnist.test.images, mnist.test.labels))
    sys.stderr.write(" [test]%s\n" % format_stats(v))
    sys.stderr.flush()
    return v

def train_batch(s, batch):
    x_v, t_v = batch
    x_v = np.reshape(x_v, [-1, 28, 28])
    s.run(
        s.train,
        feed_dict = {s.x: x_v, s.t: t_v, s.dropout: 0.5}
    )

def train(s, mnist):
    top_accuracy = max(0.99, print_stats(s, mnist)["accuracy"])
    batch_size = 100
    while True:
        for _ in range(100000 // batch_size):
            train_batch(s, mnist.train.next_batch(batch_size))
        accuracy = print_stats(s, mnist)["accuracy"]
        if (1.0 - accuracy) < 0.99 * (1.0 - top_accuracy):
            top_accuracy = accuracy
            loadsave.save(s, sys.argv[1])

def run():
    mnist = tf_mnist.input_data.read_data_sets(
        "__mnist__",
        one_hot = True
    )
    with loadsave.load(sys.argv[1], create_model = create_model) as s:
        sys.stderr.write("Training model...\n")
        sys.stderr.flush()
        train(s, mnist)

if __name__ == "__main__":
    run()
